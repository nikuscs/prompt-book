name: Release

on:
  workflow_dispatch:
    inputs:
      version_bump:
        description: Version bump type
        required: true
        default: patch
        type: choice
        options:
          - patch
          - minor
          - major

concurrency:
  group: release
  cancel-in-progress: false

permissions: {}

env:
  CARGO_TERM_COLOR: always

jobs:
  checks:
    name: Checks
    runs-on: macos-latest
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: 1.3.5

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            apps/desktop-tauri/src-tauri

      - name: Install deps
        run: bun install --frozen-lockfile

      - name: Lint
        run: bun run lint

      - name: Typecheck
        run: bun run typecheck

  create-tag:
    name: Create Tag
    needs: checks
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      version: ${{ steps.bump.outputs.version }}
      tag: ${{ steps.bump.outputs.tag }}
      commit_sha: ${{ steps.commit.outputs.sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify main branch
        run: |
          if [ "${{ github.ref }}" != "refs/heads/main" ]; then
            echo "::error::Release must be run from main branch, not ${{ github.ref }}"
            exit 1
          fi

      - name: Read current version
        id: current
        run: |
          VERSION=$(grep '^version = ' apps/desktop-tauri/src-tauri/Cargo.toml | head -1 | sed 's/version = "\(.*\)"/\1/')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $VERSION"

      - name: Bump version
        id: bump
        run: |
          CURRENT="${{ steps.current.outputs.version }}"
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"

          case "${{ inputs.version_bump }}" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Update version files
        run: |
          NEW_VERSION="${{ steps.bump.outputs.version }}"
          sed -i 's/^version = ".*"/version = "'"$NEW_VERSION"'"/' apps/desktop-tauri/src-tauri/Cargo.toml
          sed -i 's/"version": ".*"/"version": "'"$NEW_VERSION"'"/' apps/desktop-tauri/src-tauri/tauri.conf.json
          sed -i 's/"version": ".*"/"version": "'"$NEW_VERSION"'"/' apps/desktop-tauri/package.json

      - name: Commit and tag
        id: commit
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add apps/desktop-tauri/src-tauri/Cargo.toml apps/desktop-tauri/src-tauri/tauri.conf.json apps/desktop-tauri/package.json
          git commit -m "chore: bump version to ${{ steps.bump.outputs.version }}"
          echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          git tag -a "${{ steps.bump.outputs.tag }}" -m "Release ${{ steps.bump.outputs.tag }}"
          git push origin main --follow-tags

  build-and-release:
    name: Build and Release (macOS)
    needs: create-tag
    runs-on: macos-latest
    environment: release
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.create-tag.outputs.tag }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: 1.3.5

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install deps
        run: bun install --frozen-lockfile

      - name: Import Apple certificate
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          # Create keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate
          echo "$APPLE_CERTIFICATE" | base64 --decode > $RUNNER_TEMP/certificate.p12
          security import $RUNNER_TEMP/certificate.p12 -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychain -d user -s "$KEYCHAIN_PATH" $(security list-keychain -d user | tr -d '"')

          # Clean up certificate file
          rm $RUNNER_TEMP/certificate.p12

          # Verify identity is available
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"

      - name: Build and release Tauri bundles
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          APPLE_SIGNING_IDENTITY: ${{secrets.APPLE_SIGNING_IDENTITY}}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        with:
          tagName: ${{ needs.create-tag.outputs.tag }}
          releaseName: PromptBook v__VERSION__
          releaseBody: |
            Desktop release for PromptBook.
          releaseDraft: false
          prerelease: false
          projectPath: apps/desktop-tauri
          args: ""

      - name: Cleanup keychain
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true

  cleanup:
    name: Cleanup on failure
    needs: [create-tag, build-and-release]
    if: failure() && needs.create-tag.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Delete tag and revert commit
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git push --delete origin ${{ needs.create-tag.outputs.tag }} || true

          git pull origin main
          git revert ${{ needs.create-tag.outputs.commit_sha }} --no-edit
          git push origin main
